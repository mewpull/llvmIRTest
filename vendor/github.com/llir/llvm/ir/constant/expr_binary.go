// generated by gen.go using 'go generate'; DO NOT EDIT.

// === [ Binary expressions ] ==================================================
//
// References:
//    http://llvm.org/docs/LangRef.html#binary-operations

package constant

import (
	"fmt"

	"github.com/llir/llvm/ir/types"
)

// --- [ add ] -----------------------------------------------------------------

// ExprAdd represents an addition expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#add-instruction
type ExprAdd struct {
	// Operands.
	X, Y Constant
}

// NewAdd returns a new add expression based on the given operands.
func NewAdd(x, y Constant) *ExprAdd {
	return &ExprAdd{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprAdd) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprAdd) Ident() string {
	return fmt.Sprintf("add (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprAdd) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprAdd) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprAdd) MetadataNode() {}

// --- [ fadd ] ----------------------------------------------------------------

// ExprFAdd represents a floating-point addition expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fadd-instruction
type ExprFAdd struct {
	// Operands.
	X, Y Constant
}

// NewFAdd returns a new fadd expression based on the given operands.
func NewFAdd(x, y Constant) *ExprFAdd {
	return &ExprFAdd{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprFAdd) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFAdd) Ident() string {
	return fmt.Sprintf("fadd (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFAdd) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFAdd) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprFAdd) MetadataNode() {}

// --- [ sub ] -----------------------------------------------------------------

// ExprSub represents a subtraction expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#sub-instruction
type ExprSub struct {
	// Operands.
	X, Y Constant
}

// NewSub returns a new sub expression based on the given operands.
func NewSub(x, y Constant) *ExprSub {
	return &ExprSub{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprSub) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprSub) Ident() string {
	return fmt.Sprintf("sub (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprSub) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprSub) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprSub) MetadataNode() {}

// --- [ fsub ] ----------------------------------------------------------------

// ExprFSub represents a floating-point subtraction expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fsub-instruction
type ExprFSub struct {
	// Operands.
	X, Y Constant
}

// NewFSub returns a new fsub expression based on the given operands.
func NewFSub(x, y Constant) *ExprFSub {
	return &ExprFSub{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprFSub) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFSub) Ident() string {
	return fmt.Sprintf("fsub (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFSub) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFSub) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprFSub) MetadataNode() {}

// --- [ mul ] -----------------------------------------------------------------

// ExprMul represents a multiplication expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#mul-instruction
type ExprMul struct {
	// Operands.
	X, Y Constant
}

// NewMul returns a new mul expression based on the given operands.
func NewMul(x, y Constant) *ExprMul {
	return &ExprMul{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprMul) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprMul) Ident() string {
	return fmt.Sprintf("mul (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprMul) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprMul) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprMul) MetadataNode() {}

// --- [ fmul ] ----------------------------------------------------------------

// ExprFMul represents a floating-point multiplication expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fmul-instruction
type ExprFMul struct {
	// Operands.
	X, Y Constant
}

// NewFMul returns a new fmul expression based on the given operands.
func NewFMul(x, y Constant) *ExprFMul {
	return &ExprFMul{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprFMul) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFMul) Ident() string {
	return fmt.Sprintf("fmul (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFMul) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFMul) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprFMul) MetadataNode() {}

// --- [ udiv ] ----------------------------------------------------------------

// ExprUDiv represents an unsigned division expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#udiv-instruction
type ExprUDiv struct {
	// Operands.
	X, Y Constant
}

// NewUDiv returns a new udiv expression based on the given operands.
func NewUDiv(x, y Constant) *ExprUDiv {
	return &ExprUDiv{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprUDiv) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprUDiv) Ident() string {
	return fmt.Sprintf("udiv (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprUDiv) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprUDiv) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprUDiv) MetadataNode() {}

// --- [ sdiv ] ----------------------------------------------------------------

// ExprSDiv represents a signed division expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#sdiv-instruction
type ExprSDiv struct {
	// Operands.
	X, Y Constant
}

// NewSDiv returns a new sdiv expression based on the given operands.
func NewSDiv(x, y Constant) *ExprSDiv {
	return &ExprSDiv{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprSDiv) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprSDiv) Ident() string {
	return fmt.Sprintf("sdiv (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprSDiv) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprSDiv) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprSDiv) MetadataNode() {}

// --- [ fdiv ] ----------------------------------------------------------------

// ExprFDiv represents a floating-point division expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fdiv-instruction
type ExprFDiv struct {
	// Operands.
	X, Y Constant
}

// NewFDiv returns a new fdiv expression based on the given operands.
func NewFDiv(x, y Constant) *ExprFDiv {
	return &ExprFDiv{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprFDiv) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFDiv) Ident() string {
	return fmt.Sprintf("fdiv (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFDiv) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFDiv) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprFDiv) MetadataNode() {}

// --- [ urem ] ----------------------------------------------------------------

// ExprURem represents an unsigned remainder expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#urem-instruction
type ExprURem struct {
	// Operands.
	X, Y Constant
}

// NewURem returns a new urem expression based on the given operands.
func NewURem(x, y Constant) *ExprURem {
	return &ExprURem{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprURem) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprURem) Ident() string {
	return fmt.Sprintf("urem (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprURem) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprURem) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprURem) MetadataNode() {}

// --- [ srem ] ----------------------------------------------------------------

// ExprSRem represents a signed remainder expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#srem-instruction
type ExprSRem struct {
	// Operands.
	X, Y Constant
}

// NewSRem returns a new srem expression based on the given operands.
func NewSRem(x, y Constant) *ExprSRem {
	return &ExprSRem{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprSRem) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprSRem) Ident() string {
	return fmt.Sprintf("srem (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprSRem) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprSRem) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprSRem) MetadataNode() {}

// --- [ frem ] ----------------------------------------------------------------

// ExprFRem represents a floating-point remainder expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#frem-instruction
type ExprFRem struct {
	// Operands.
	X, Y Constant
}

// NewFRem returns a new frem expression based on the given operands.
func NewFRem(x, y Constant) *ExprFRem {
	return &ExprFRem{
		X: x,
		Y: y,
	}
}

// Type returns the type of the constant expression.
func (expr *ExprFRem) Type() types.Type {
	return expr.X.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFRem) Ident() string {
	return fmt.Sprintf("frem (%s %s, %s %s)",
		expr.X.Type(),
		expr.X.Ident(),
		expr.Y.Type(),
		expr.Y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFRem) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFRem) Simplify() Constant {
	panic("not yet implemented")
}

// MetadataNode ensures that only metadata nodes can be assigned to the
// ir.MetadataNode interface.
func (*ExprFRem) MetadataNode() {}
