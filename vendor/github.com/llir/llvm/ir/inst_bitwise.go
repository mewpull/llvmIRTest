// generated by gen.go using 'go generate'; DO NOT EDIT.

// === [ Bitwise instructions ] ================================================
//
// References:
//    http://llvm.org/docs/LangRef.html#bitwise-binary-operations

package ir

import (
	"fmt"

	"github.com/llir/llvm/internal/enc"
	"github.com/llir/llvm/ir/metadata"
	"github.com/llir/llvm/ir/types"
	"github.com/llir/llvm/ir/value"
)

// --- [ shl ] -----------------------------------------------------------------

// InstShl represents a shift left instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#shl-instruction
type InstShl struct {
	// Parent basic block.
	Parent *BasicBlock
	// Name of the local variable associated with the instruction.
	Name string
	// Operands.
	X, Y value.Value
	// Map from metadata identifier (e.g. !dbg) to metadata associated with the
	// instruction.
	Metadata map[string]*metadata.Metadata
}

// NewShl returns a new shl instruction based on the given operands.
func NewShl(x, y value.Value) *InstShl {
	return &InstShl{
		X:        x,
		Y:        y,
		Metadata: make(map[string]*metadata.Metadata),
	}
}

// Type returns the type of the instruction.
func (inst *InstShl) Type() types.Type {
	return inst.X.Type()
}

// Ident returns the identifier associated with the instruction.
func (inst *InstShl) Ident() string {
	return enc.Local(inst.Name)
}

// GetName returns the name of the local variable associated with the
// instruction.
func (inst *InstShl) GetName() string {
	return inst.Name
}

// SetName sets the name of the local variable associated with the instruction.
func (inst *InstShl) SetName(name string) {
	inst.Name = name
}

// String returns the LLVM syntax representation of the instruction.
func (inst *InstShl) String() string {
	md := metadataString(inst.Metadata, ",")
	return fmt.Sprintf("%s = shl %s %s, %s%s",
		inst.Ident(),
		inst.Type(),
		inst.X.Ident(),
		inst.Y.Ident(),
		md)
}

// GetParent returns the parent basic block of the instruction.
func (inst *InstShl) GetParent() *BasicBlock {
	return inst.Parent
}

// SetParent sets the parent basic block of the instruction.
func (inst *InstShl) SetParent(parent *BasicBlock) {
	inst.Parent = parent
}

// --- [ lshr ] ----------------------------------------------------------------

// InstLShr represents a logical shift right instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#lshr-instruction
type InstLShr struct {
	// Parent basic block.
	Parent *BasicBlock
	// Name of the local variable associated with the instruction.
	Name string
	// Operands.
	X, Y value.Value
	// Map from metadata identifier (e.g. !dbg) to metadata associated with the
	// instruction.
	Metadata map[string]*metadata.Metadata
}

// NewLShr returns a new lshr instruction based on the given operands.
func NewLShr(x, y value.Value) *InstLShr {
	return &InstLShr{
		X:        x,
		Y:        y,
		Metadata: make(map[string]*metadata.Metadata),
	}
}

// Type returns the type of the instruction.
func (inst *InstLShr) Type() types.Type {
	return inst.X.Type()
}

// Ident returns the identifier associated with the instruction.
func (inst *InstLShr) Ident() string {
	return enc.Local(inst.Name)
}

// GetName returns the name of the local variable associated with the
// instruction.
func (inst *InstLShr) GetName() string {
	return inst.Name
}

// SetName sets the name of the local variable associated with the instruction.
func (inst *InstLShr) SetName(name string) {
	inst.Name = name
}

// String returns the LLVM syntax representation of the instruction.
func (inst *InstLShr) String() string {
	md := metadataString(inst.Metadata, ",")
	return fmt.Sprintf("%s = lshr %s %s, %s%s",
		inst.Ident(),
		inst.Type(),
		inst.X.Ident(),
		inst.Y.Ident(),
		md)
}

// GetParent returns the parent basic block of the instruction.
func (inst *InstLShr) GetParent() *BasicBlock {
	return inst.Parent
}

// SetParent sets the parent basic block of the instruction.
func (inst *InstLShr) SetParent(parent *BasicBlock) {
	inst.Parent = parent
}

// --- [ ashr ] ----------------------------------------------------------------

// InstAShr represents an arithmetic shift right instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#ashr-instruction
type InstAShr struct {
	// Parent basic block.
	Parent *BasicBlock
	// Name of the local variable associated with the instruction.
	Name string
	// Operands.
	X, Y value.Value
	// Map from metadata identifier (e.g. !dbg) to metadata associated with the
	// instruction.
	Metadata map[string]*metadata.Metadata
}

// NewAShr returns a new ashr instruction based on the given operands.
func NewAShr(x, y value.Value) *InstAShr {
	return &InstAShr{
		X:        x,
		Y:        y,
		Metadata: make(map[string]*metadata.Metadata),
	}
}

// Type returns the type of the instruction.
func (inst *InstAShr) Type() types.Type {
	return inst.X.Type()
}

// Ident returns the identifier associated with the instruction.
func (inst *InstAShr) Ident() string {
	return enc.Local(inst.Name)
}

// GetName returns the name of the local variable associated with the
// instruction.
func (inst *InstAShr) GetName() string {
	return inst.Name
}

// SetName sets the name of the local variable associated with the instruction.
func (inst *InstAShr) SetName(name string) {
	inst.Name = name
}

// String returns the LLVM syntax representation of the instruction.
func (inst *InstAShr) String() string {
	md := metadataString(inst.Metadata, ",")
	return fmt.Sprintf("%s = ashr %s %s, %s%s",
		inst.Ident(),
		inst.Type(),
		inst.X.Ident(),
		inst.Y.Ident(),
		md)
}

// GetParent returns the parent basic block of the instruction.
func (inst *InstAShr) GetParent() *BasicBlock {
	return inst.Parent
}

// SetParent sets the parent basic block of the instruction.
func (inst *InstAShr) SetParent(parent *BasicBlock) {
	inst.Parent = parent
}

// --- [ and ] -----------------------------------------------------------------

// InstAnd represents an AND instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#and-instruction
type InstAnd struct {
	// Parent basic block.
	Parent *BasicBlock
	// Name of the local variable associated with the instruction.
	Name string
	// Operands.
	X, Y value.Value
	// Map from metadata identifier (e.g. !dbg) to metadata associated with the
	// instruction.
	Metadata map[string]*metadata.Metadata
}

// NewAnd returns a new and instruction based on the given operands.
func NewAnd(x, y value.Value) *InstAnd {
	return &InstAnd{
		X:        x,
		Y:        y,
		Metadata: make(map[string]*metadata.Metadata),
	}
}

// Type returns the type of the instruction.
func (inst *InstAnd) Type() types.Type {
	return inst.X.Type()
}

// Ident returns the identifier associated with the instruction.
func (inst *InstAnd) Ident() string {
	return enc.Local(inst.Name)
}

// GetName returns the name of the local variable associated with the
// instruction.
func (inst *InstAnd) GetName() string {
	return inst.Name
}

// SetName sets the name of the local variable associated with the instruction.
func (inst *InstAnd) SetName(name string) {
	inst.Name = name
}

// String returns the LLVM syntax representation of the instruction.
func (inst *InstAnd) String() string {
	md := metadataString(inst.Metadata, ",")
	return fmt.Sprintf("%s = and %s %s, %s%s",
		inst.Ident(),
		inst.Type(),
		inst.X.Ident(),
		inst.Y.Ident(),
		md)
}

// GetParent returns the parent basic block of the instruction.
func (inst *InstAnd) GetParent() *BasicBlock {
	return inst.Parent
}

// SetParent sets the parent basic block of the instruction.
func (inst *InstAnd) SetParent(parent *BasicBlock) {
	inst.Parent = parent
}

// --- [ or ] ------------------------------------------------------------------

// InstOr represents an OR instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#or-instruction
type InstOr struct {
	// Parent basic block.
	Parent *BasicBlock
	// Name of the local variable associated with the instruction.
	Name string
	// Operands.
	X, Y value.Value
	// Map from metadata identifier (e.g. !dbg) to metadata associated with the
	// instruction.
	Metadata map[string]*metadata.Metadata
}

// NewOr returns a new or instruction based on the given operands.
func NewOr(x, y value.Value) *InstOr {
	return &InstOr{
		X:        x,
		Y:        y,
		Metadata: make(map[string]*metadata.Metadata),
	}
}

// Type returns the type of the instruction.
func (inst *InstOr) Type() types.Type {
	return inst.X.Type()
}

// Ident returns the identifier associated with the instruction.
func (inst *InstOr) Ident() string {
	return enc.Local(inst.Name)
}

// GetName returns the name of the local variable associated with the
// instruction.
func (inst *InstOr) GetName() string {
	return inst.Name
}

// SetName sets the name of the local variable associated with the instruction.
func (inst *InstOr) SetName(name string) {
	inst.Name = name
}

// String returns the LLVM syntax representation of the instruction.
func (inst *InstOr) String() string {
	md := metadataString(inst.Metadata, ",")
	return fmt.Sprintf("%s = or %s %s, %s%s",
		inst.Ident(),
		inst.Type(),
		inst.X.Ident(),
		inst.Y.Ident(),
		md)
}

// GetParent returns the parent basic block of the instruction.
func (inst *InstOr) GetParent() *BasicBlock {
	return inst.Parent
}

// SetParent sets the parent basic block of the instruction.
func (inst *InstOr) SetParent(parent *BasicBlock) {
	inst.Parent = parent
}

// --- [ xor ] -----------------------------------------------------------------

// InstXor represents an exclusive-OR instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#xor-instruction
type InstXor struct {
	// Parent basic block.
	Parent *BasicBlock
	// Name of the local variable associated with the instruction.
	Name string
	// Operands.
	X, Y value.Value
	// Map from metadata identifier (e.g. !dbg) to metadata associated with the
	// instruction.
	Metadata map[string]*metadata.Metadata
}

// NewXor returns a new xor instruction based on the given operands.
func NewXor(x, y value.Value) *InstXor {
	return &InstXor{
		X:        x,
		Y:        y,
		Metadata: make(map[string]*metadata.Metadata),
	}
}

// Type returns the type of the instruction.
func (inst *InstXor) Type() types.Type {
	return inst.X.Type()
}

// Ident returns the identifier associated with the instruction.
func (inst *InstXor) Ident() string {
	return enc.Local(inst.Name)
}

// GetName returns the name of the local variable associated with the
// instruction.
func (inst *InstXor) GetName() string {
	return inst.Name
}

// SetName sets the name of the local variable associated with the instruction.
func (inst *InstXor) SetName(name string) {
	inst.Name = name
}

// String returns the LLVM syntax representation of the instruction.
func (inst *InstXor) String() string {
	md := metadataString(inst.Metadata, ",")
	return fmt.Sprintf("%s = xor %s %s, %s%s",
		inst.Ident(),
		inst.Type(),
		inst.X.Ident(),
		inst.Y.Ident(),
		md)
}

// GetParent returns the parent basic block of the instruction.
func (inst *InstXor) GetParent() *BasicBlock {
	return inst.Parent
}

// SetParent sets the parent basic block of the instruction.
func (inst *InstXor) SetParent(parent *BasicBlock) {
	inst.Parent = parent
}
